回顾内容
1.openstack架构搭建
2.各个组件nova/cinder/glance/heat
----

面试：这件事情和你学习一样，是需要突击的，需要专项有针对性练习的。

今日内容
1.swift

对象存储

能否说下存储分类？
按照组网维度：DAS/NAS/SAN（IP-SAN、FC-SAN 交换机[博科光纤交换机]）
按照形态维度：集中式存储/分布式存储
按照业务类型维度：块存储/文件存储/对象存储

块存储：U盘、移动硬盘、磁盘等，如果要使用它，对其进行分区格式化，windows（NTFS）,Linux（ext2/ext3/ext4/xfs....），场景：企业级数据库，大量读写场景
文件存储：主打共享，NAS 群晖/华为家庭存储...，文件存储它的文件系统不依赖于上层客户端操作系统，存储本身就自带了文件系统。上层ios/Android/linux/windows
对象存储：新兴技术，融合了NAS共享和SAN高性能。二层文件系统，只有两级架构，一级容器，容器里面对象，对象包含key/metadata/data

metadata 元数据：描述数据的数据。个人信息表里面的数据（描述性数据），就是你这个人的元数据。

/account：账户，请注意账户，不是用户的意思，而是一个具体的存储路径（存储的地方），相当于/根目录
/account/container：容器，进入到account之后，可以看到这个account下面的所有的容器
/account/container/object：对象，进入到container容器后，可以看到该容器下的所有对象

理解switf如何将一个对象存储到磁盘上。
底层磁盘会经过哈希运算会多点分布到哈希环上，以此来达到相对均衡的目的，即便后续有增加、删除磁盘的操作，那么相对来说，影响范围较小。

实验：
最终要实现的效果，我上传一个对象，会自动保存到对象存储里面（容器里面），对象存储的后端指向两个我们自定义的空间，之后到底层查看，有两份数据（双副本）
1）控制节点上增加一块硬盘，添加20G（分两个分区，每个分区10G，分区格式化并挂载）
[root@controller node]# pwd
/srv/node

[root@controller node]# mkdir aaa bbb
[root@controller node]# ll
total 4
drwxr-xr-x  2 root  root     6 Jan  6 20:41 aaa
drwxr-xr-x  2 root  root     6 Jan  6 20:41 bbb
drwxr-xr-x. 7 swift swift 4096 Jan  5 11:41 swiftloopback

修改目录权限
[root@controller node]# chown swift.swift aaa
[root@controller node]# chown swift.swift bbb
[root@controller node]# ll
total 4
drwxr-xr-x  2 swift swift    6 Jan  6 20:41 aaa
drwxr-xr-x  2 swift swift    6 Jan  6 20:41 bbb
drwxr-xr-x. 7 swift swift 4096 Jan  5 11:41 swiftloopback

2）卸载原有的swift对应的虚拟块设备，并挂载新的目录
界面上清除对象存储里面的数据
卸载虚拟块设备
[root@controller node]# umount /srv/node/swiftloopback

[root@controller node]# vim /etc/fstab
[root@controller node]# cat /etc/fstab
# HEADER: This file was autogenerated at 2024-12-19 21:45:55 +0800
# HEADER: by puppet.  While it can still be managed manually, it
# HEADER: is definitely not recommended.

#
# /etc/fstab
# Created by anaconda on Sat Sep 21 06:58:15 2024
#
# Accessible filesystems, by reference, are maintained under '/dev/disk/'.
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.
#
# After editing this file, run 'systemctl daemon-reload' to update systemd
# units generated from this file.
#
/dev/mapper/cl-root     /       xfs     defaults        0       0
UUID=a3e6b6dc-966e-4461-80f2-81f74aa0d5ef       /boot   xfs     defaults        0       0
/dev/mapper/cl-home     /home   xfs     defaults        0       0
/dev/mapper/cl-swap     none    swap    defaults        0       0
\#/srv/loopback-device/swiftloopback     /srv/node/swiftloopback ext4    noatime,nodiratime,nofail,loop,user_xattr       0       0
/dev/nvme0n2p1  /srv/node/aaa   xfs     defaults        0       0
/dev/nvme0n2p2  /srv/node/bbb   xfs     defaults        0       0
[root@controller node]#
[root@controller node]# df -Th
......
/dev/nvme0n2p1      xfs        10G  104M  9.9G   2% /srv/node/aaa
/dev/nvme0n2p2      xfs        10G  104M  9.9G   2% /srv/node/bbb


3）创建builder
这个builder是为了后续创建ring存在的。
创建的builder的时候，会让我们指定规则，后续ring环分区数、副本数、修改间隔时间等。builder对外表现是一个文件。
cd /etc/swift

[root@controller swift]# mv account.builder account.builder.bak
[root@controller swift]# mv container.builder container.builder.bak
[root@controller swift]# mv object.builder object.builder.bak
创建builder的语法规则
swift-ring-builder <builder_file> create <part_power> <replicas> <min_part_hours>

swift-ring-builder account.builder create 12 2 1
swift-ring-builder container.builder create 12 2 1
swift-ring-builder object.builder create 12 2 1

swift-ring-builder account.builder create 12 1 1
swift-ring-builder container.builder create 12 1 1
swift-ring-builder object.builder create 12 1 1

12表示的是2的12次方，未来ring环会被切分成多少个区间
2表示的是多少副本数，双副本
1表示的是一旦ring环被创建（意味着规则生效），1小时内不允许修改。

builder文件
属性：
1.多少个分区数
2.多少个副本数
3.限制修改时间
4.映射到哪个zone

4）创建builder和zone的映射关系

删除或重命名之前的ring文件.gz

[root@controller swift]# mv account.ring.gz account.ring.gz.bak
[root@controller swift]# mv container.ring.gz container.ring.gz.bak
[root@controller swift]# mv object.ring.gz object.ring.gz.bak

mv account.ring.gz account.ring.gz.bak
mv container.ring.gz container.ring.gz.bak
mv object.ring.gz object.ring.gz.bak

语法结构：
swift-ring-builder <builder_file> add
    [r<region>]z<zone>-<ip>:<port>[R<r_ip>:<r_port>]/<device_name>_<meta>
     <weight>
    [[r<region>]z<zone>-<ip>:<port>[R<r_ip>:<r_port>]/<device_name>_<meta>
     <weight>] ...

swift-ring-builder account.builder add z1-192.168.44.100:6002/aaa 100
swift-ring-builder account.builder add z2-192.168.44.100:6002/bbb 100

swift-ring-builder container.builder add z1-192.168.44.100:6001/aaa 100
swift-ring-builder container.builder add z2-192.168.44.100:6001/bbb 100

swift-ring-builder object.builder add z1-192.168.44.100:6000/aaa 100
swift-ring-builder object.builder add z2-192.168.44.100:6000/bbb 100

swift-ring-builder account.builder add z1-192.168.44.100:6002/nfsdata 100
swift-ring-builder container.builder add z1-192.168.44.100:6001/nfsdata 100
swift-ring-builder object.builder add z1-192.168.44.100:6000/nfsdata 100

5）再平衡（通过builer文件创建ring文件）
[root@controller swift]# swift-ring-builder account.builder rebalance
Reassigned 8192 (200.00%) partitions. Balance is now 0.00.  Dispersion is now 0.00

[root@controller swift]# swift-ring-builder container.builder rebalance
Reassigned 8192 (200.00%) partitions. Balance is now 0.00.  Dispersion is now 0.00

[root@controller swift]# swift-ring-builder object.builder rebalance
Reassigned 8192 (200.00%) partitions. Balance is now 0.00.  Dispersion is now 0.00

6）测试
界面上通过上传一个镜像，之后底层观察数据条目
[root@controller node]# find . -name *data*
./aaa/objects/593/55f/251544c5add13fc17df8760d9e5f755f/1736169620.43071.data
./aaa/objects/3128/b93/c38baa3c06d2b02e87daf3e3d0f9eb93/1736169620.68294.data
./bbb/objects/593/55f/251544c5add13fc17df8760d9e5f755f/1736169620.43071.data
./bbb/objects/3128/b93/c38baa3c06d2b02e87daf3e3d0f9eb93/1736169620.68294.data

多副本，容灾，灾备：解决的是业务连续性，高可用，不能解决数据丢失问题（不是底层设备引起，而是由上层用户引起的）
备份：解决的是数据完整性。不小心删除了，由于介质损坏导致的数据丢失，都可以通过备份找回来。
生产环境都会使用备份加容灾方案。

2.keystone
3.neutron OVN架构