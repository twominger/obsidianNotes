配置项
secret
configmap

比如创建一些需要传递变量的pod时候，如果直接通过命令行或者编写yaml文件，这时候就会暴露密码，不安全。
secret就可以针对变量、密码等进行封装的，之后在yaml文件中进行引用即可。通过base64加密，可以进行卷挂载方式，也可以进行变量传递方式，更加适用后者。
configmap针对参数文件、配置文件等进行封装的，之后在yaml文件中进行引用。明文，不加密，可以进行卷挂载方式，也可以进行变量传递方式，更加适用前者。

deployment管理的pod，滚动更新
deployment管理3个副本（3个pod），原来1.25，当你更新pod的时候，1.27，那么之前pod中的参数文件、配置文件全部清空（因为是重新创建的pod）。
这时候就可以创建一个configmap针对参数文件或者配置文件进行封装。未来在yaml文件中进行挂载引用。

# secret
## secret 创建语法
[root@master ~]# kubectl create secret generic -h |grep -i from
  kubectl create secret generic my-secret --from-file=path/to/bar
  kubectl create secret generic my-secret --from-file=ssh-privatekey=path/to/id_rsa --from-file=ssh-publickey=path/to/id_rsa.pub
  kubectl create secret generic my-secret --from-literal=key1=supersecret --from-literal=key2=topsecret
  kubectl create secret generic my-secret --from-file=ssh-privatekey=path/to/id_rsa --from-literal=passphrase=topsecret
  # Create a new secret named my-secret from env files
  kubectl create secret generic my-secret --from-env-file=path/to/foo.env --from-env-file=path/to/bar.env
    --from-env-file=[]:
    --from-file=[]:
    --from-literal=[]:
  kubectl create secret generic NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run=server|client|none] [options]

--from-env-file=[]: 多个变量参数方式（批量数据），可以将参数名=参数值，全部以此写入到某个文件中。--from-env-file aaa
--from-file=[]: 如果你是一个文件，它会将文件名作为参数名，文件中的所有内容作为一个参数值。
--from-literal=[]: 单个变量参数方式 --from-literal MYSQL_ROOT_PASSWORD=redhat --from-literal MYSQL_DATABASE=wordpress 

[root@master ~]# kubectl create secret generic sec01 --from-literal MYSQL_ROOT_PASSWORD=redhat --from-literal MYSQL_DATABASE=wordpress
secret/sec01 created
[root@master ~]# kubectl get secrets
NAME    TYPE     DATA   AGE
sec01   Opaque   2      6s

[root@master ~]# kubectl get secrets sec01 -o yaml
apiVersion: v1
data:
  MYSQL_DATABASE: d29yZHByZXNz
  MYSQL_ROOT_PASSWORD: cmVkaGF0
kind: Secret
metadata:
  creationTimestamp: "2025-02-22T01:35:50Z"
  name: sec01
  namespace: default
  resourceVersion: "2061548"
  uid: 80eafec1-481d-4c26-a91b-c959cb92d06b
type: Opaque
[root@master ~]#
[root@master ~]# echo d29yZHByZXNz |base64 -d
wordpress[root@master ~]#
[root@master ~]#
[root@master ~]# echo cmVkaGF0 |base64 -d
redhat[root@master ~]#


[root@master ~]# vim aaa
[root@master ~]# cat aaa
MYSQL_ROOT_PASSWOR=redhat
MYSQL_DATABASE=wordpress
aaa=111
bbb=222
ccc=333

[root@master ~]# kubectl create secret generic sec02 --from-env-file aaa
secret/sec02 created
[root@master ~]# kubectl get secrets
NAME    TYPE     DATA   AGE
sec01   Opaque   2      5m24s
sec02   Opaque   5      8s


[root@master ~]# kubectl create secret generic sec03 --from-file aaa
secret/sec03 created
[root@master ~]# kubectl get secrets sec03
NAME    TYPE     DATA   AGE
sec03   Opaque   1      14s

## secret用法
1.通过文件形式挂载
[root@master ~]# kubectl create secret generic sec04 --from-file index.html
secret/sec04 created
[root@master ~]# kubectl get secrets sec04 -o yaml
apiVersion: v1
data:
  index.html: MTExMTEK
kind: Secret
metadata:
  creationTimestamp: "2025-02-22T01:48:47Z"
  name: sec04
  namespace: default
  resourceVersion: "2063597"
  uid: 0adc6245-0e85-400e-acda-067d0bccc089
type: Opaque

[root@master ~]# cat pod1.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: pod1
  name: pod1
spec:
  containers:
  - image: nginx
    name: pod1
    resources: {}
    volumeMounts:
    - name: s1
      mountPath: /usr/share/nginx/html
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  volumes:
  - name: s1
    secret:
      secretName: sec04
status: {}

[root@master ~]# kubectl apply -f pod1.yaml
[root@master ~]# kubectl exec -ti pod1 -- cat /usr/share/nginx/html/index.html
11111

2.变量方式
类似于mysql的pod，如果单单依赖于上面的文件方式挂载，无法实现的。因为mysql在创建的过程中，需要变量和参数的传递。
my.cnf 参数文件可以使用文件方式挂载，但是这一步是在你的容器正常启动后才去挂载的。

[root@master ~]# kubectl get secrets
NAME    TYPE     DATA   AGE
sec01   Opaque   2      22m
sec02   Opaque   5      16m
sec03   Opaque   1      14m
sec04   Opaque   1      9m3s
[root@master ~]# kubectl get secrets sec01 -o yaml
apiVersion: v1
data:
  MYSQL_DATABASE: d29yZHByZXNz
  MYSQL_ROOT_PASSWORD: cmVkaGF0
kind: Secret
metadata:
  creationTimestamp: "2025-02-22T01:35:50Z"
  name: sec01
  namespace: default
  resourceVersion: "2061548"
  uid: 80eafec1-481d-4c26-a91b-c959cb92d06b
type: Opaque

[root@master ~]# kubectl run db --image mysql --dry-run=client -o yaml > db.yaml
[root@master ~]# vim db.yaml
[root@master ~]# vim db.yaml
[root@master ~]# cat db.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: db
  name: db
spec:
  containers:
  - image: mysql
    name: db
    resources: {}
    env:
    - name: MYSQL_ROOT_PASSWORD
      valueFrom:
        secretKeyRef:
          name: sec01
          key: MYSQL_ROOT_PASSWORD
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
[root@master ~]# kubectl apply -f db.yaml

[root@master ~]# mysql -uroot -p -h 10.244.166.190
Enter password:
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 9
Server version: 9.2.0 MySQL Community Server - GPL

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.004 sec)

MySQL [(none)]>

# configmap
## configmap 语法
```shell
[root@master ~]# kubectl create configmap -h |grep from
  kubectl create configmap my-config --from-file=path/to/bar
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2
  # Create a new config map named my-config from the key=value pairs in the file
  kubectl create configmap my-config --from-file=path/to/bar
  # Create a new config map named my-config from an env file
  kubectl create configmap my-config --from-env-file=path/to/foo.env --from-env-file=path/to/bar.env
    --from-env-file=[]:
    --from-file=[]:
    --from-literal=[]:
  kubectl create configmap NAME [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run=server|client|none] [options]
```

[root@master ~]# cat index.html
11111
[root@master ~]# kubectl get cm
NAME               DATA   AGE
kube-root-ca.crt   1      89d
[root@master ~]#
[root@master ~]# kubectl create configmap cm1 --from-file index.html
configmap/cm1 created
[root@master ~]# kubectl get cm
NAME               DATA   AGE
cm1                1      3s
kube-root-ca.crt   1      89d

[root@master ~]# vim web1.yaml
[root@master ~]# cat web1.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: web1
  name: web1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web1
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: web1
    spec:
      containers:
      - image: nginx
        name: nginx
        resources: {}
        volumeMounts:
        - name: s1
          mountPath: /usr/share/nginx/html/
      volumes:
      - name: s1
        configMap:
          name: cm1
status: {}
[root@master ~]# kubectl get pod
NAME                                      READY   STATUS    RESTARTS      AGE
db                                        1/1     Running   0             8m46s
nfs-client-provisioner-5c578b7757-lg659   1/1     Running   1 (40h ago)   5d18h
pod1                                      1/1     Running   0             118s
[root@master ~]# kubectl delete -f pod1.yaml
pod "pod1" deleted
k[root@master ~]#
[root@master ~]# kubectl apply -f web1.yaml
deployment.apps/web1 created
[root@master ~]# kubectl get pod
NAME                                      READY   STATUS              RESTARTS      AGE
db                                        1/1     Running             0             9m2s
nfs-client-provisioner-5c578b7757-lg659   1/1     Running             1 (40h ago)   5d18h
web1-69484c96cb-6db55                     0/1     ContainerCreating   0             2s
web1-69484c96cb-cxptq                     0/1     ContainerCreating   0             2s
web1-69484c96cb-hgf6c                     0/1     ContainerCreating   0             2s
[root@master ~]# kubectl get pod
NAME                                      READY   STATUS              RESTARTS      AGE
db                                        1/1     Running             0             9m4s
nfs-client-provisioner-5c578b7757-lg659   1/1     Running             1 (40h ago)   5d18h
web1-69484c96cb-6db55                     1/1     Running             0             4s
web1-69484c96cb-cxptq                     0/1     ContainerCreating   0             4s
web1-69484c96cb-hgf6c                     1/1     Running             0             4s
[root@master ~]# kubectl get pod
NAME                                      READY   STATUS    RESTARTS      AGE
db                                        1/1     Running   0             9m5s
nfs-client-provisioner-5c578b7757-lg659   1/1     Running   1 (40h ago)   5d18h
web1-69484c96cb-6db55                     1/1     Running   0             5s
web1-69484c96cb-cxptq                     1/1     Running   0             5s
web1-69484c96cb-hgf6c                     1/1     Running   0             5s
[root@master ~]#
[root@master ~]# kubectl exec -ti web1-69484c96cb-6db55 -- nginx -v
nginx version: nginx/1.27.4
[root@master ~]# kubectl exec -ti web1-69484c96cb-6db55 -- cat /usr/share/nginx/html/index.html
11111

现在模拟滚动更新，更新成1.26.3

[root@master ~]# kubectl set image deployments web1 nginx=nginx:1.26.3 --record=true
Flag --record has been deprecated, --record will be removed in the future
deployment.apps/web1 image updated
[root@master ~]# kubectl get pod
NAME                                      READY   STATUS    RESTARTS      AGE
db                                        1/1     Running   0             10m
nfs-client-provisioner-5c578b7757-lg659   1/1     Running   1 (40h ago)   5d18h
web1-5487cf6b8d-4g6rg                     1/1     Running   0             11s
web1-5487cf6b8d-csfvn                     1/1     Running   0             5s
web1-5487cf6b8d-fcn2k                     1/1     Running   0             8s
[root@master ~]# kubectl exec -ti web1-5487cf6b8d-4g6rg -- cat /usr/share/nginx/html/index.html
11111
[root@master ~]# kubectl exec -ti web1-5487cf6b8d-4g6rg -- nginx -v
nginx version: nginx/1.26.3

# 身份认证及角色权限
https://kubernetes.io/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/
## 身份认证
1.kubeconfig
kubeconfig方式是通过加载/etc/kubernetes/admin.conf 这个文件来实现的。

[root@master kubernetes]# scp admin.conf 192.168.44.202:/tmp
The authenticity of host '192.168.44.202 (192.168.44.202)' can't be established.
ECDSA key fingerprint is SHA256:VkjaqBSycziUNstxpth1MmkhPy0z/yj2I3oDdKvPh9A.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.44.202' (ECDSA) to the list of known hosts.
root@192.168.44.202's password:
admin.conf    

[root@node1 ~]# kubectl get node --kubeconfig=/tmp/admin.conf
NAME     STATUS   ROLES    AGE   VERSION
master   Ready    master   89d   v1.31.3
node1    Ready    n1       89d   v1.31.3
node2    Ready    n2       89d   v1.31.3

但是，权限太大，这时候需要单独创建用户，单独授权。
创建一个用户 natasha 娜塔莎

1）生成用户私钥文件
[root@master ~]# mkdir /ca
[root@master ~]# cd /ca
[root@master ca]# openssl genrsa -out client.key 2048
Generating RSA private key, 2048 bit long modulus (2 primes)
............+++++
............+++++
e is 65537 (0x010001)
[root@master ca]# ls
client.key

2）为natasha生成请求证书
[root@master ca]# openssl req -new -key client.key -subj "/CN=natasha" -out client.csr
[root@master ca]# ls
client.csr  client.key

3）为natasha颁发证书文件
[root@master ca]# openssl x509 -req -in client.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial  -out client.crt -days 3650
Signature ok
subject=CN = natasha
Getting CA Private Key
[root@master ca]# ls
client.crt  client.csr  client.key

[root@master ca]# cp /etc/kubernetes/pki/ca.crt .
[root@master ca]# ls
ca.crt  client.crt  client.csr  client.key

4）创建新的ns
[root@master ca]# kubectl create ns hehe

5）在hehe ns 创建pod
[root@master ca]# kubectl get pod
No resources found in hehe namespace.
[root@master ca]# kubectl run pod1 --image nginx
pod/pod1 created
[root@master ca]# kubectl get pod
NAME   READY   STATUS    RESTARTS   AGE
pod1   1/1     Running   0          3s

6）创建一个角色并对角色进行授权
[root@master ca]# kubectl create role r1 --verb get --verb watch --verb list --resource pods -n hehe
role.rbac.authorization.k8s.io/r1 created
[root@master ca]# kubectl get role
NAME   CREATED AT
r1     2025-02-22T02:57:57Z

创建r1角色，该角色只能限定在hehe命名空间中，针对pod这一种对象/资源，进行get/watch/list

[root@master ca]# kubectl describe role r1
Name:         r1
Labels:       <none>
Annotations:  <none>
PolicyRule:
  Resources  Non-Resource URLs  Resource Names  Verbs
  ---------  -----------------  --------------  -----
  pods       []                 []              [get watch list]

7）将r1角色绑定给用户natasha
[root@master ca]# kubectl create rolebinding r1binding --role r1 --user natasha -n hehe
rolebinding.rbac.authorization.k8s.io/r1binding created
[root@master ca]# kubectl get rolebindings.rbac.authorization.k8s.io
NAME        ROLE      AGE
r1binding   Role/r1   3s
[root@master ca]# kubectl describe rolebindings.rbac.authorization.k8s.io
Name:         r1binding
Labels:       <none>
Annotations:  <none>
Role:
  Kind:  Role
  Name:  r1
Subjects:
  Kind  Name     Namespace
  ----  ----     ---------
  User  natasha

8）为natasha用户创建配置文件

首先编辑一个模板文件
[root@master ca]# cat natasha.conf
apiVersion: v1
kind: Config

clusters:
- cluster:
  name: dev1

users:
- name: natasha

contexts:
- context:
  name: context1
  namespace: hehe
current-context: "context1"

将密钥信息嵌入到这个模板里面
设置集群密钥信息（嵌入集群密钥）
[root@kmaster ca]# kubectl config --kubeconfig=natasha.conf set-cluster dev1 --server=https://192.168.44.201:6443 --certificate-authority=ca.crt --embed-certs=true

设置tom用户密钥信息
[root@kmaster ca]# kubectl config --kubeconfig=natasha.conf set-credentials natasha --client-certificate=client.crt --client-key=client.key --embed-certs=true

设置上下文信息
[root@kmaster ca]# kubectl config --kubeconfig=natasha.conf set-context context1 --cluster=dev1 --namespace=hehe --user=natasha

9) 测试
[root@master ca]# scp natasha.conf 192.168.44.203:/tmp
The authenticity of host '192.168.44.203 (192.168.44.203)' can't be established.
ECDSA key fingerprint is SHA256:ceHmNkNSPfk1MiT0zLFkNfEBACAE/T1mIrs654PjNkk.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.44.203' (ECDSA) to the list of known hosts.
root@192.168.44.203's password:
natasha.conf                                                                                                100% 5390     2.3MB/s   00:00

在node2上测试
[root@node2 ~]# kubectl get node --kubeconfig=/tmp/natasha.conf
Error from server (Forbidden): nodes is forbidden: User "natasha" cannot list resource "nodes" in API group "" at the cluster scope
[root@node2 ~]#
[root@node2 ~]# kubectl get pod --kubeconfig=/tmp/natasha.conf
NAME   READY   STATUS    RESTARTS   AGE
pod1   1/1     Running   0          22m

为什么直接可以查询到hehe ns 的pod？因为在natasha.conf中，设置的上下文就指定了默认的ns 是 hehe

2.静态token
静态令牌文件
令牌文件是一个 CSV 文件，包含至少 3 个列：令牌、用户名和用户的 UID。 其余列被视为可选的组名。
如果要设置的组名不止一个，则对应的列必须用双引号括起来，例如：token,user,uid,"group1,group2,group3"
[root@master ca]# vim abc.csv
[root@master ca]# cat abc.csv
e1a6b5e073f8da224c3e,tom,3
[root@master ca]# mv abc.csv /etc/kubernetes/pki/

[root@kmaster ca]# vim /etc/kubernetes/manifests/kube-apiserver.yaml 

  containers:
  - command:
    - kube-apiserver
    - --advertise-address=192.168.100.180
    - --token-auth-file=/etc/kubernetes/pki/abc.csv
/etc/kubernetes/pki/abc.csv 该文件就是保存用户账号和密码的。建议不要更换目录，因为k8s本身是对该目录有足够权限的。

保存退出之后，api-server会自动重启，需要等待一会。必须等待状态正常。

随便找一个节点，进行测试
[root@node1 ~]# kubectl --server='https://192.168.44.201:6443' --token='e1a6b5e073f8da224c3e' --insecure-skip-tls-verify=true get pod -n hehe

Error from server (Forbidden): pods is forbidden: User "tom" cannot list resource "pods" in API group "" in the namespace "hehe"

因为没有给角色和权限
为tom创建一个角色，并将角色绑定给tom
[root@master ~]# kubectl create role r2 --verb get --verb watch --verb list --resource pods -n hehe
role.rbac.authorization.k8s.io/r2 created
[root@master ~]# kubectl create rolebinding r2binding --role r2 --user tom -n hehe
rolebinding.rbac.authorization.k8s.io/r2binding created
[root@master ~]# kubectl get rolebindings.rbac.authorization.k8s.io
NAME        ROLE      AGE
r1binding   Role/r1   35m
r2binding   Role/r2   5s

测试
[root@node1 ~]# kubectl --server='https://192.168.44.201:6443' --token='e1a6b5e073f8da224c3e' --insecure-skip-tls-verify=true get pod -n hehe
NAME   READY   STATUS    RESTARTS   AGE
pod1   1/1     Running   0          47m
[root@node1 ~]# kubectl --server='https://192.168.44.201:6443' --token='e1a6b5e073f8da224c3e' --insecure-skip-tls-verify=true get pod -n memeda
Error from server (Forbidden): pods is forbidden: User "tom" cannot list resource "pods" in API group "" in the namespace "memeda"
[root@node1 ~]# kubectl --server='https://192.168.44.201:6443' --token='e1a6b5e073f8da224c3e' --insecure-skip-tls-verify=true get pvc -n hehe
Error from server (Forbidden): persistentvolumeclaims is forbidden: User "tom" cannot list resource "persistentvolumeclaims" in API group "" in the namespace "hehe"
[root@node1 ~]#
[root@node1 ~]# alias kubectl='kubectl --server='https://192.168.44.201:6443' --token='e1a6b5e073f8da224c3e' --insecure-skip-tls-verify=true'
[root@node1 ~]# alias

[root@node1 ~]# kubectl get pod -n hehe
NAME   READY   STATUS    RESTARTS   AGE
pod1   1/1     Running   0          48m

## 角色及授权
role/rolebinding
clusterrole/clusterrolebinding

role/rolebinding：作用在ns级别
clusterrole/clusterrolebinding：作用在集群全局级别

问：需求
1.针对某个用户，让这个用户限定在某个ns中，而且限定某些资源。
2.针对某个用户，让这个用户可以查看所有ns，以及操作所有ns中的所有资源。

1.role/rolebingding

是基于命名空间来授权的

get

list  ——————> 全部给到 role1 角色（基于命名空间） ---> 给到tom用户
                       abc
create

如果在创建role的时候，没有指定ns，那么默认不允许访问任何ns

流程两步走：1.创建role，设定ns和操作的对象及权限；2.将role和用户进行rolebinding

[root@master ~]# cat r3.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  name: r3
  namespace: default
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
  - delete
[root@master ~]# cat r3binding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  creationTimestamp: null
  name: r3binding
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: r3
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: tom

[root@master ~]# kubectl apply -f r3.yaml
role.rbac.authorization.k8s.io/r3 created
[root@master ~]# kubectl apply -f r3binding.yaml
rolebinding.rbac.authorization.k8s.io/r3binding created

再次通过tom用户测试
[root@node1 ~]# kubectl get pod -n default
NAME                                      READY   STATUS    RESTARTS      AGE
db                                        1/1     Running   0             116m
nfs-client-provisioner-5c578b7757-lg659   1/1     Running   4 (31m ago)   5d20h
web1-5487cf6b8d-4g6rg                     1/1     Running   0             105m
web1-5487cf6b8d-csfvn                     1/1     Running   0             105m
web1-5487cf6b8d-fcn2k                     1/1     Running   0             105m
[root@node1 ~]#
[root@node1 ~]# kubectl get pod -n hehe
NAME   READY   STATUS    RESTARTS   AGE
pod1   1/1     Running   0          67m

https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authorization/

tom用户 
绑定了一个角色 r2，可以针对 hehe 命名空间进行pod的操作，get watch list
绑定了一个角色 r3，可以针对 default 命名空间进行pod的操作，get list watch delete create

后面具体的api动作是根据ns来绑定的。

在ns hehe 中，有一个r2

[root@master ~]# kubectl get role
NAME   CREATED AT
r1     2025-02-22T02:57:57Z
r2     2025-02-22T03:36:10Z  --> get watch list


[root@master ~]# kubectl get rolebindings.rbac.authorization.k8s.io
NAME        ROLE      AGE
r1binding   Role/r1   3h35m
r2binding   Role/r2   3h    --> r2和tom

[root@node1 ~]# kubectl delete pods/pod1 -n hehe
Error from server (Forbidden): pods "pod1" is forbidden: User "tom" cannot delete resource "pods" in API group "" in the namespace "hehe"
删除的时候报错，为什么？因为给tom用户绑定的r2这个角色细项中，没有delete。加上delete测试下
[root@master ~]# kubectl edit role r2

apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: "2025-02-22T03:36:10Z"
  name: r2
  namespace: hehe
  resourceVersion: "2110806"
  uid: 8d0615a9-f576-4be0-a065-9cd21c1a2400
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - watch
  - list
  - delete
回到客户端，测试删除
[root@node1 ~]# kubectl delete pods/pod1 -n hehe
pod "pod1" deleted

现在可以create吗？
[root@node1 ~]# kubectl run pod1 --image nginx -n hehe
Error from server (Forbidden): pods is forbidden: User "tom" cannot create resource "pods" in API group "" in the namespace "hehe"

不能，没有对应的权限细项，加上create
[root@node1 ~]# kubectl run pod1 --image nginx -n hehe
pod/pod1 created
[root@node1 ~]# kubectl get pod -n hehe
NAME   READY   STATUS    RESTARTS   AGE
pod1   1/1     Running   0          2s

既然现在create权限有了，那么能否create一个deployment呢？
[root@node1 ~]# kubectl create deployment web2 --image nginx -n default
error: failed to create deployment: deployments.apps is forbidden: User "tom" cannot create resource "deployments" in API group "apps" in the namespace "default"

为什么？因为r3针对的资源只有一个pods，没有deployments，这时候加上deployments，再次执行后，发现还是创建不了
[root@master ~]# cat r3.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  name: r3
  namespace: default
rules:
- apiGroups:
  - ""
  resources:
  - pods
  - deployments
  verbs:
  - get
  - list
  - watch
  - delete
  - create

[root@node1 ~]# kubectl create deployment web2 --image nginx -n default
error: failed to create deployment: deployments.apps is forbidden: User "tom" cannot create resource "deployments" in API group "apps" in the namespace "default"

你会发现，查询deploy是不可以的。因为deploy

pod--apiversion v1
services--apiversion v1
deployment--apps/v1
不同的这些资源类型，他们的apiversion是不一样的。查询集群中所有的apiversion
[root@kmaster ~]# kubectl api-versions 
[root@kmaster ~]# kubectl api-resources -o wide
这里面version分为两种，一种带斜杠，一种不带斜杠。前者是两级结构，后者一级结构。

deployment对应的apiversion为两级结构，所以，要写两级，要把父级写入到apigroup里面，才能生效。而pod和svc都是一级结构，所以父级apigroup为空。

所以改一下：
[root@master ~]# cat r3.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  name: r3
  namespace: default
rules:
- apiGroups:
  - ""
  - "apps"
  resources:
  - pods
  - deployments
  verbs:
  - get
  - list
  - watch
  - delete
  - create
[root@master ~]# kubectl apply -f r3.yaml

再次客户端测试
[root@node1 ~]# kubectl create deployment web2 --image nginx -n default
deployment.apps/web2 created

既然是一个deployment，之前讲过，如何修改副本数。
[root@node1 ~]# kubectl scale deployment web2 --replicas 3 -n default
Error from server (Forbidden): deployments.apps "web2" is forbidden: User "tom" cannot patch resource "deployments/scale" in API group "apps" in the namespace "default"

修改role
[root@master ~]# cat r3.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  name: r3
  namespace: default
rules:
- apiGroups:
  - ""
  - "apps"
  resources:
  - pods
  - deployments
  - deployments/scale
  verbs:
  - get
  - list
  - watch
  - delete
  - create
  - patch

再测试
[root@node1 ~]# kubectl scale deployment web2 --replicas 3 -n default
deployment.apps/web2 scaled
[root@node1 ~]# kubectl get pod -n default
NAME                                      READY   STATUS    RESTARTS      AGE
db                                        1/1     Running   1 (30m ago)   5h
nfs-client-provisioner-5c578b7757-lg659   1/1     Running   5 (29m ago)   5d23h
pod2                                      1/1     Running   0             13m
web1-5487cf6b8d-4g6rg                     1/1     Running   1 (30m ago)   4h49m
web1-5487cf6b8d-csfvn                     1/1     Running   1 (30m ago)   4h49m
web1-5487cf6b8d-ldvmt                     1/1     Running   1 (29m ago)   34m
web2-5497857fc9-bwc2s                     1/1     Running   0             8s
web2-5497857fc9-mcxhl                     1/1     Running   0             5m43s
web2-5497857fc9-vflg9                     1/1     Running   0             8s

总结：角色针对权限管理一共分为3个部分（apigroups/resources/verbs）

写法也可以采用中括号（数组形式）
rules:
- apiGroups:
  - ""
  - "apps"
  resources:
  - pods
  - deployments
  - deployments/scale
  verbs:
  - get
  - list
  - watch
  - delete
  - create
  - patch

可以改为
rules:
- apiGroups: ["","apps"]
  resources: ["pods","deployments","deployments/scale"]
  verbs: ["get","list","watch","delete","create","patch","update"]

针对不同的对象，有不同的权限
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get","list","watch"]

- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get","list","watch","create"]

以上的作用域是在ns级别。并不是整个集群的。

2.clusterrole/clusterrolebinding

是基于所有命名空间来授权的

get

list  ——————> 全部给到 clusterrole1 角色（基于集群所有命名空间） ---> 给到tom用户

creat

注意先把tom的环境还原下，删除所有关于tom的role和rolebinding

[root@master ~]# kubectl create clusterrole clsr1 --verb get,watch,list --resource pods --dry-run=client -o yaml > clsr1.yaml
[root@master ~]# vim clsr1.yaml
[root@master ~]# cat clsr1.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  name: clsr1
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - watch
  - list
[root@master ~]# kubectl apply -f clsr1.yaml
clusterrole.rbac.authorization.k8s.io/clsr1 created
[root@master ~]# kubectl get clusterrole |grep clsr1
clsr1                                                                  2025-02-22T07:14:30Z

[root@master ~]# kubectl create clusterrolebinding clsbinr1 --clusterrole clsr1 --user tom --dry-run=client -o yaml > clsbinr1.yaml
[root@master ~]# cat clsbinr1.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  creationTimestamp: null
  name: clsbinr1
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: clsr1
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: tom
[root@master ~]# kubectl apply -f clsbinr1.yaml
clusterrolebinding.rbac.authorization.k8s.io/clsbinr1 created

[root@node1 ~]# kubectl get pod -A

## SA ServiceAccount
不管是natasha还是tom，这些账号是给用户使用的。
RBAC分为2种账户：

user account 用户账号（UA）：用于远程登陆系统，也就是我们在刚刚实验所使用的账号
service account 服务账户（SA）：Service account是为了方便Pod里面的进程（而非人工）调用Kubernetes API或其他外部服务而设计的。例如使用web来管理k8s环境时，需要调用相关的程序（pod中）有对K8s管理，当时此程序需要有相关的权限，这时候就可以创建一个SA，赋予相关的权限，并且与管理K8s的环境程序进行绑定，那么这个程序就有了SA的对应权限，可以对K8s进行管理。

在k8s集中群，用户分为 useraccount和serviceaccount，前者用于做登录限制授权使用，后者用于给应用程序授权，不会让用户直接登录。
k8s集群中很多组件都是基于pod来运行的。比如，需要某个pod里面的应用程序来监控或操作集群资源，自动扩展、缩容，部署新的pod。
但是pod里面运行的是某个进程，该进程要去管理集群里面的资源，是否有权限吗？
这个时候，就需要通过授权指定pod里面的进程，要以哪个sa（服务账号）来运行。该sa是否有足够的权限，如果没有，需要对sa进行授权

举例：创建一个pod
假设该pod里面的进程未来要管理集群资源。
[root@kmaster ~]# cat web1.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: web1
  name: web1
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web1
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: web1
    spec:
      containers:
      - image: nginx
        imagePullPolicy: IfNotPresent
        name: nginx
        resources: {}
status: {}

[root@kmaster ~]# kubectl get pod
NAME                   READY   STATUS    RESTARTS   AGE
pod1                   1/1     Running   0          31m
web1-849556688-j7wpx   1/1     Running   0          44m
web1-849556688-jgwmj   1/1     Running   0          44m


[root@kmaster ~]# kubectl get sa
NAME      SECRETS   AGE
default   0         55d
[root@kmaster ~]# kubectl create sa sa1
serviceaccount/sa1 created
[root@kmaster ~]# kubectl get sa
NAME      SECRETS   AGE
default   0         55d
sa1       0         3s

这时候的sa1是没有任何权限的。将集群管理员角色授权binding给sa1

[root@kmaster ~]# kubectl create clusterrolebinding rbsa1 --clusterrole admin --serviceaccount hehe:sa666 
clusterrolebinding.rbac.authorization.k8s.io/rbsa1 created

将服务账号，给到deploy pod（里面的进程）。查看下当前deploy里面的内容：
[root@kmaster ~]# kubectl edit deployments.apps web1 

  securityContext: {}

把sa1账号绑定给deploy
[root@kmaster ~]# kubectl set serviceaccount deploy web1 sa1
deployment.apps/web1 serviceaccount updated
再次查看
[root@kmaster ~]# kubectl edit deployments.apps web1 

      securityContext: {}
      serviceAccount: sa01
      serviceAccountName: sa01

这个时候，deploy里面的pod就具备了admin的权限了。

查询sa和关联的角色
kubectl get rolebindings,clusterrolebindings \
--all-namespaces  \
-o custom-columns='KIND:kind,NAMESPACE:metadata.namespace,NAME:metadata.name,SERVICE_ACCOUNTS:subjects[?(@.kind=="ServiceAccount")].name'

## 图形化管理
dashboard：官方图形化管理工具
https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/

创建SA

[root@kmaster ~]# kubectl create sa sa2 -n kube-system
serviceaccount/sa2 created
[root@kmaster ~]# kubectl get sa -n kube-system 

[root@kmaster ~]# kubectl create clusterrolebinding rbsa2 --clusterrole admin --serviceaccount kube-system:sa2 -n kube-system
clusterrolebinding.rbac.authorization.k8s.io/rbsa2 created

[root@kmaster ~]# kubectl get sa sa2 -n kube-system 
NAME   SECRETS   AGE
sa2    0         3m36s

创建secrets
[root@kmaster ~]# vim sa2-secret.yaml
[root@kmaster ~]# cat sa2-secret.yaml 
apiVersion: v1
kind: Secret
metadata:
  name: secret-sa-sample
  annotations:
    kubernetes.io/service-account.name: "sa2"
type: kubernetes.io/service-account-token

[root@kmaster ~]# kubectl apply -f sa2-secret.yaml -n kube-system 
secret/secret-sa-sample created

为了方便操作，切换到kube-system
[root@kmaster ~]# kubectl get secrets 
NAME               TYPE                                  DATA   AGE
secret-sa-sample   kubernetes.io/service-account-token   3      24s
[root@kmaster ~]# kubectl describe secrets secret-sa-sample 
Name:         secret-sa-sample
Namespace:    kube-system
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: sa2
              kubernetes.io/service-account.uid: c67402c3-8624-4627-961b-8a8a4fe9f2f6

Type:  kubernetes.io/service-account-token

Data
====
namespace:  11 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IkF4WWpqdzhfNDB6UWVjNXZRTzA0cEZsWGdJT2tQTl9Bc05qZF9PTWQwakUifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJzZWNyZXQtc2Etc2FtcGxlIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6InNhMiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImM2NzQwMmMzLTg2MjQtNDYyNy05NjFiLThhOGE0ZmU5ZjJmNiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTpzYTIifQ.5cgYpF4Et6RdaVLCalGhozQRAVWi6q6TcwTDD5e2pjdu6YNxiUd_GV0dqkqMmy5AGxcZziucRzhBa3Jo48YMKnZ12lG3MInN8BiUJxeYLfYgSjf-EnnbX9n6EfFbYNjE9E2s6ZbfEJvzmo7eHKHPc6tDQ7WTcKU3t1bp89Umn33s8iToLWiHbCPx_oXbK3Bp7-CxgwqXEy-BDRjynTJoLuYPIK_VNtMR3Mj7LqktxtbjPLy5cIP6XYPapi4fe2tQPMpWrVRoN27j2HzhI13B9lofO2DnwZ21J77j16vvef4tqIMB1_zdeenPBTa1p7fwTP8geVxJPPrNkWEeuHx7IA
ca.crt:     1099 bytes

这个token就是admin角色的值。记好。
开始安装dashboard

采用yaml文件创建（群里获取）如果过期了，用下面的链接
https://gitee.com/tianhairui/yaml/blob/master/recommended.yaml

[root@kmaster ~]# vim recommended.yaml
[root@kmaster ~]# grep image recommended.yaml 
          image: kubernetesui/dashboard:v2.7.0
          imagePullPolicy: Always
          image: kubernetesui/metrics-scraper:v1.0.8

更换成阿里云的镜像地址

registry.cn-hangzhou.aliyuncs.com/cloudcs/dashboard:v2.7.0
registry.cn-hangzhou.aliyuncs.com/cloudcs/metrics-scraper:v1.0.8

[root@kmaster ~]# grep image recommended.yaml 
          image: registry.cn-hangzhou.aliyuncs.com/cloudcs/dashboard:v2.7.0
          imagePullPolicy: IfNotPresent
          image: registry.cn-hangzhou.aliyuncs.com/cloudcs/metrics-scraper:v1.0.8

[root@kmaster ~]# kubectl apply -f recommended.yaml 
namespace/kubernetes-dashboard created
serviceaccount/kubernetes-dashboard created
service/kubernetes-dashboard created
secret/kubernetes-dashboard-certs created
secret/kubernetes-dashboard-csrf created
secret/kubernetes-dashboard-key-holder created
configmap/kubernetes-dashboard-settings created
role.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created
rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
deployment.apps/kubernetes-dashboard created
service/dashboard-metrics-scraper created
deployment.apps/dashboard-metrics-scraper created

[root@kmaster ~]# kubectl get ns
NAME                   STATUS   AGE
calico-apiserver       Active   55d
calico-system          Active   55d
default                Active   55d
kube-node-lease        Active   55d
kube-public            Active   55d
kube-system            Active   55d
kubernetes-dashboard   Active   35s
tigera-operator        Active   55d
[root@kmaster ~]# kubectl get pods -n kubernetes-dashboard 
NAME                                         READY   STATUS    RESTARTS   AGE
dashboard-metrics-scraper-67f9cdfb55-pzqj5   1/1     Running   0          60s
kubernetes-dashboard-67d48649d5-sbbql        1/1     Running   0          60s
[root@kmaster ~]# kubectl get svc -n kubernetes-dashboard 
NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
dashboard-metrics-scraper   ClusterIP   10.107.56.187   <none>        8000/TCP   74s
kubernetes-dashboard        ClusterIP   10.111.104.11   <none>        443/TCP    74s

[root@kmaster ~]# kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard 
service/kubernetes-dashboard edited

  sessionAffinity: None
  type: NodePort

[root@kmaster ~]# kubectl get svc -n kubernetes-dashboard 
NAME                        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE
dashboard-metrics-scraper   ClusterIP   10.107.56.187   <none>        8000/TCP        3m18s
kubernetes-dashboard        NodePort    10.111.104.11   <none>        443:31485/TCP   3m18s

访问集群master 带上端口号（注意https）
https://192.168.146.139:31485/#/login

可以选择config方式，也可以token方式登录（上面生成的）。
关于token如何创建，也可以参考官方链接：
https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md

类似于其他的三方工具：
https://www.rancher.com/
https://github.com/kubesphere/kubesphere/blob/master/README_zh.md

# helm
harbor/helm/istio等写一本书

包管理器 
rpm包，yum dnf

思考：pod/deployment等对象，创建管理他们的，pod/pvc/pv/deployment/sc等等，这些资源都是单独手工创建的。

我们可以把这些yaml文件汇总到一起，放在同一个目录中，这个目录就成为一个chart

HELM ^4f9c1d

在linux里面安装rpm包的时候，可以通过yum/dnf来安装，自动解决所有包依赖关系。

helm作用是把许多定义（pod、svc、pvc、pv。。。），比如 svc，deployment等一次性全部定义好，放在源里统一管理。

对于helm来说，要安装软件，需要提前编辑 yaml 文件。
它可以帮助我们进行一键式安装应用。
网上存在很多打包好的应用，互联网上有很多源，类似于yum源，源里面有很多包

本质上来说，包管理器helm就是yaml模板。你可以把所有yaml文件放在同一个目录中，封装成一个包，但这个包并不具备通用性。如果别人需要修改，还是需要打开包修改源码。
这就需要一个同一个包管理工具，按照固定的格式进行定制。

源1             源2
包1 包2.tar   包3 包4
     |
     |
     |
包可以下载本地，也是通过helm下载到本地。下载好之后手工解压。下载的tar叫做包。
tar--解压--得到文件夹（叫chart，里面包含了创建应用的所有的属性）---------> k8s 环境
这时候，本地安装了helm之后，根据chart要求进行部署安装，helm会自动的部署到k8s环境里面。

另外，也可以在线指定源，不需要下载，自动部署。建议下载过来。

helm版本

v2和v3 版本

v2版本有些复杂。
v3版本简化了很多操作，没有了tiller端，只有单纯的helm客户端。

安装过程
https://helm.sh/docs/intro/install/

下载软件
https://github.com/helm/helm/releases/tag/v3.11.2

helm-v3.11.2-linux-amd64.tar.gz

解压
[root@kmaster1 ~]# tar -zxvf helm-v3.11.2-linux-amd64.tar.gz 
linux-amd64/
linux-amd64/helm
linux-amd64/LICENSE
linux-amd64/README.md
[root@kmaster1 ~]# ls
anaconda-ks.cfg  bridge-utils-1.5-9.el7.x86_64.rpm  helm-v3.11.2-linux-amd64.tar.gz  linux-amd64  Stream8_docker.sh
[root@kmaster1 ~]# cd linux-amd64/
[root@kmaster1 linux-amd64]# ls
helm  LICENSE  README.md
[root@kmaster1 linux-amd64]# mv helm /usr/local/bin/helm
[root@kmaster1 linux-amd64]# 
[root@kmaster1 linux-amd64]# 
[root@kmaster1 linux-amd64]# helm help


配置环境
LICENSE    README.md  
helm completion bash > ~/.helm
helm completion bash > ~/.helmrc
echo "source ~/.helmrc" >> ~/.bashrc 
source ~/.bashrc

配置仓库，阿里云无法使用

微软的chart仓库
http://mirror.azure.cn/kubernetes/charts/
这个仓库强烈推荐，基本上官网有的chart这里都有。

[root@kmaster1 linux-amd64]# helm repo add weiruan http://mirror.azure.cn/kubernetes/charts/
"weiruan" has been added to your repositories
[root@kmaster1 linux-amd64]# helm repo list
NAME   	URL                                      
weiruan	http://mirror.azure.cn/kubernetes/charts/

删除源
[root@kmaster1 linux-amd64]# helm repo 
add     (add a chart repository)                                                  remove  (remove one or more chart repositories)
index   (generate an index file given a directory containing packaged charts)     update  (update information of available charts locally from chart repositories)
list    (list chart repositories)                                                 
[root@kmaster1 linux-amd64]# helm repo remove weiruan 
"weiruan" has been removed from your repositories

[root@kmaster1 linux-amd64]# helm search repo mysql
NAME                             	CHART VERSION	APP VERSION	DESCRIPTION                                       
weiruan/mysql                    	1.6.9        	5.7.30     	DEPRECATED - Fast, reliable, scalable, and easy...
weiruan/mysqldump                	2.6.2        	2.4.1      	DEPRECATED! - A Helm chart to help backup MySQL...
weiruan/prometheus-mysql-exporter	0.7.1        	v0.11.0    	DEPRECATED A Helm chart for prometheus mysql ex...
weiruan/percona                  	1.2.3        	5.7.26     	DEPRECATED - free, fully compatible, enhanced, ...
weiruan/percona-xtradb-cluster   	1.0.8        	5.7.19     	DEPRECATED - free, fully compatible, enhanced, ...
weiruan/phpmyadmin               	4.3.5        	5.0.1      	DEPRECATED phpMyAdmin is an mysql administratio...
weiruan/gcloud-sqlproxy          	0.6.1        	1.11       	DEPRECATED Google Cloud SQL Proxy                 
weiruan/mariadb                  	7.3.14       	10.3.22    	DEPRECATED Fast, reliable, scalable, and easy t...

[root@kmaster1 linux-amd64]# helm pull weiruan/mysql
[root@kmaster1 linux-amd64]# ls
LICENSE  mysql-1.6.9.tgz  README.md

[root@kmaster1 linux-amd64]# ls
LICENSE  mysql-1.6.9.tgz  README.md
[root@kmaster1 linux-amd64]# tar -zxvf mysql-1.6.9.tgz 
mysql/Chart.yaml
mysql/values.yaml
mysql/templates/NOTES.txt
mysql/templates/_helpers.tpl
mysql/templates/configurationFiles-configmap.yaml
mysql/templates/deployment.yaml
mysql/templates/initializationFiles-configmap.yaml
mysql/templates/pvc.yaml
mysql/templates/secrets.yaml
mysql/templates/serviceaccount.yaml
mysql/templates/servicemonitor.yaml
mysql/templates/svc.yaml
mysql/templates/tests/test-configmap.yaml
mysql/templates/tests/test.yaml
mysql/.helmignore
mysql/README.md
[root@kmaster1 linux-amd64]# ls
LICENSE  mysql  mysql-1.6.9.tgz  README.md
[root@kmaster1 linux-amd64]# rm -rf mysql-1.6.9.tgz 
[root@kmaster1 linux-amd64]# helm package mysql/
Successfully packaged chart and saved it to: /root/linux-amd64/mysql-1.6.9.tgz
[root@kmaster1 linux-amd64]# ls
LICENSE  mysql  mysql-1.6.9.tgz  README.md

这个目录就是一个chart，也可以在本地打包
[root@kmaster mysql]# cd ..
[root@kmaster linux-amd64]# ls
LICENSE  mysql  mysql-1.6.9.tgz  README.md
[root@kmaster linux-amd64]# rm -rf mysql-1.6.9.tgz 
[root@kmaster linux-amd64]# helm package mysql/
Successfully packaged chart and saved it to: /root/linux-amd64/mysql-1.6.9.tgz
[root@kmaster linux-amd64]# ls
LICENSE  mysql  mysql-1.6.9.tgz  README.md

这里文件夹就是一个mysql，打包后，它怎么知道具体版本的呢？这里有个chart的文件，里面记录了元数据信息。

[root@kmaster linux-amd64]# cd mysql/
[root@kmaster mysql]# ls
Chart.yaml  README.md  templates  values.yaml


[root@kmaster mysql]# cat Chart.yaml 
apiVersion: v1
appVersion: 5.7.30
deprecated: true
description: DEPRECATED - Fast, reliable, scalable, and easy to use open-source relational
  database system.
home: https://www.mysql.com/
icon: https://www.mysql.com/common/logos/logo-mysql-170x115.png
keywords:
- mysql
- database
- sql
name: mysql
sources:
- https://github.com/kubernetes/charts
- https://github.com/docker-library/mysql
version: 1.6.9
[root@kmaster mysql]# 

然后根据values文件，部署pod
查看values文件内容

版本可以改为最新的
busybox:
  image: "busybox"
  tag: "latest"

testFramework关闭
testFramework:
  enabled: false

mysql的root密码
  ## Default: random 10 character string
mysqlRootPassword: memeda

是否使用持久卷，改为false
## Persist data to a persistent volume
persistence:
  enabled: false

关闭ssl
ssl:
  enabled: false

那么这个yaml文件里面指定的这么多参数，它是如何自动创建的呢？比如持久卷如何创建？
[root@kmaster mysql]# ls
Chart.yaml  README.md  templates  values.yaml
[root@kmaster mysql]# ls templates/
configurationFiles-configmap.yaml  _helpers.tpl                        NOTES.txt  secrets.yaml         servicemonitor.yaml  tests
deployment.yaml                    initializationFiles-configmap.yaml  pvc.yaml   serviceaccount.yaml  svc.yaml

在templates目录里面，有很多yaml文件，比如pvc，svc，secrests等等。就是通过这个yaml来创建的。而这个文件里面记录的都是变量，根据变量去取值。

接下来我们通过helm来部署一个应用。
[root@kmaster mysql]# helm ls
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION

可以在本地构建
helm install name chart目录
也可以在线构建
helm install name 源/名称

一般来说，使用公共的helm源，是不知道里面具体要设置什么值，建议最好down下来。

[root@kmaster mysql]# cd ..
[root@kmaster linux-amd64]# ls
LICENSE  mysql  mysql-1.6.9.tgz  README.md
[root@kmaster linux-amd64]# helm install db mysql
mysql/           mysql-1.6.9.tgz  
[root@kmaster linux-amd64]# helm install db mysql/
WARNING: This chart is deprecated
NAME: db
LAST DEPLOYED: Sat Apr 22 21:50:38 2023
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
db-mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default db-mysql -o jsonpath="{.data.mysql-root-password}" | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update && apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h db-mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/db-mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}

[root@kmaster linux-amd64]#  helm ls
NAME	NAMESPACE	REVISION	UPDATED                                	STATUS  	CHART      	APP VERSION
db  	default  	1       	2023-04-22 21:50:38.157284162 +0800 CST	deployed	mysql-1.6.9	5.7.30     

[root@kmaster linux-amd64]# kubectl get pod -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES
db-mysql-86f5ff66dc-zt8lb   1/1     Running   0          69s   10.244.195.133   knode1   <none>           <none>

安装客户端，尝试连接
[root@kmaster linux-amd64]# yum install -y mariadb
[root@kmaster linux-amd64]# mysql -uroot -pmemeda -h 10.244.195.133
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MySQL connection id is 22
Server version: 5.7.30 MySQL Community Server (GPL)

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MySQL [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.001 sec)

MySQL [(none)]> 

删除helm
[root@kmaster linux-amd64]# helm ls
NAME	NAMESPACE	REVISION	UPDATED                                	STATUS  	CHART      	APP VERSION
db  	default  	1       	2023-04-22 21:50:38.157284162 +0800 CST	deployed	mysql-1.6.9	5.7.30     
[root@kmaster linux-amd64]# helm delete db
release "db" uninstalled
[root@kmaster linux-amd64]# helm ls
NAME	NAMESPACE	REVISION	UPDATED	STATUS	CHART	APP VERSION
[root@kmaster linux-amd64]# kubectl get pod
No resources found in default namespace.

使用helm安装软件包的时候，都是连接到互联网上去，但是生产环境有可能无法联网，这时候我们就可以选择搭建自己的私有仓库。比如就拿mysql为例。
用一个web服务器（为了方便演示，直接使用容器来做），创建一个新的目录，专门保存包资源。

[root@knode2 ~]# docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
[root@knode2 ~]# docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
a2abf6c4d29d: Pull complete 
a9edb18cadd1: Pull complete 
589b7251471a: Pull complete 
186b1aaa4aa6: Pull complete 
b4df32aa5a72: Pull complete 
a0bcbecc962e: Pull complete 
Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest
[root@knode2 ~]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
nginx        latest    605c77e624dd   15 months ago   141MB

[root@knode2 ~]# docker run -tid --name web-chart --restart always -p 80:80 -v /charts:/usr/share/nginx/html/charts nginx
8ab605382848ab548fbcd98b0406560d5f3b9e4561e6c74774556ee475d951dd

注意：当我们访问node2主机ip的时候，默认加载的网站跟目录为 /usr/share/nginx/html，如果要访问charts目录，则是主机ip/charts
首先将chart目录进行打包
 [root@kmaster linux-amd64]# ls
LICENSE  mysql  mysql-1.6.9.tgz  README.md
[root@kmaster linux-amd64]# mkdir aaa
[root@kmaster linux-amd64]# helm package mysql
Successfully packaged chart and saved it to: /root/linux-amd64/mysql-1.6.9.tgz
[root@kmaster linux-amd64]# ls
aaa  LICENSE  mysql  mysql-1.6.9.tgz  README.md
[root@kmaster linux-amd64]# cp mysql-1.6.9.tgz aaa/
[root@kmaster linux-amd64]# ls aaa/
mysql-1.6.9.tgz

为mysql包创建索引信息
[root@kmaster linux-amd64]# helm repo index aaa/ --url http://192.168.146.141/charts
[root@kmaster linux-amd64]# ls aaa/
index.yaml  mysql-1.6.9.tgz

[root@kmaster linux-amd64]# cat aaa/index.yaml 
apiVersion: v1
entries:
  mysql:
  - apiVersion: v1
    appVersion: 5.7.30
    created: "2022-04-22T22:10:06.970175025+08:00"
    deprecated: true
    description: DEPRECATED - Fast, reliable, scalable, and easy to use open-source
      relational database system.
    digest: 7c1e3d7c890cc2ed306d47ebd9f8b1d4b493e9caab296c5f29ff8af94fcd7373
    home: https://www.mysql.com/
    icon: https://www.mysql.com/common/logos/logo-mysql-170x115.png
    keywords:
    - mysql
    - database
    - sql
    name: mysql
    sources:
    - https://github.com/kubernetes/charts
    - https://github.com/docker-library/mysql
    urls:
    - http://192.168.146.141/charts/mysql-1.6.9.tgz
    version: 1.6.9
generated: "2022-04-22T22:10:06.969209519+08:00"

将aaa目录下的索引文件及包资源拷贝到容器web服务器里面
[root@kmaster linux-amd64]# scp aaa/* 192.168.146.141:/charts
root@192.168.146.141's password: 
index.yaml                                                                                                        100%  742     1.8MB/s   00:00    
mysql-1.6.9.tgz                                                                                                   100%   11KB   8.4MB/s   00:00    
[root@kmaster linux-amd64]# 

[root@knode2 ~]# ls /charts/
index.yaml  mysql-1.6.9.tgz

[root@knode2 ~]# docker ps -a
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES
8ab605382848   nginx     "/docker-entrypoint.…"   13 minutes ago   Up 13 minutes   0.0.0.0:80->80/tcp, :::80->80/tcp   web-chart
[root@knode2 ~]# docker exec -ti web-chart /bin/bash
root@8ab605382848:/# ls /usr/share/nginx/html/charts/
index.yaml  mysql-1.6.9.tgz

做好之后，在helm中添加新的本地仓库。
[root@kmaster linux-amd64]# helm repo add myrepo http://192.168.146.141/charts
"myrepo" has been added to your repositories
[root@kmaster linux-amd64]# helm repo list
NAME   	URL                                      
weiruan	http://mirror.azure.cn/kubernetes/charts/
myrepo 	http://192.168.146.141/charts 

这样，私有仓库就搭建好了。查询下。
[root@kmaster linux-amd64]# helm search repo mysql
NAME                             	CHART VERSION	APP VERSION	DESCRIPTION                                       
myrepo/mysql                     	1.6.9        	5.7.30     	DEPRECATED - Fast, reliable, scalable, and easy...
weiruan/mysql                    	1.6.9        	5.7.30     	DEPRECATED - Fast, reliable, scalable, and easy...
weiruan/mysqldump                	2.6.2        	2.4.1      	DEPRECATED! - A Helm chart to help backup MySQL...
weiruan/prometheus-mysql-exporter	0.7.1        	v0.11.0    	DEPRECATED A Helm chart for prometheus mysql ex...
weiruan/percona                  	1.2.3        	5.7.26     	DEPRECATED - free, fully compatible, enhanced, ...
weiruan/percona-xtradb-cluster   	1.0.8        	5.7.19     	DEPRECATED - free, fully compatible, enhanced, ...
weiruan/phpmyadmin               	4.3.5        	5.0.1      	DEPRECATED phpMyAdmin is an mysql administratio...
weiruan/gcloud-sqlproxy          	0.6.1        	1.11       	DEPRECATED Google Cloud SQL Proxy                 
weiruan/mariadb                  	7.3.14       	10.3.22    	DEPRECATED Fast, reliable, scalable, and easy t...

通过helm私有仓库在线安装mysql。
[root@kmaster linux-amd64]# kubectl get pod
No resources found in default namespace.
[root@kmaster linux-amd64]# hel
helm  help  
[root@kmaster linux-amd64]# helm install db myrepo/mysql
WARNING: This chart is deprecated
NAME: db
LAST DEPLOYED: Sat Apr 22 22:25:41 2023
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
db-mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default db-mysql -o jsonpath="{.data.mysql-root-password}" | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update && apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h db-mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/db-mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}
[root@kmaster linux-amd64]# kubectl get pod -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP               NODE     NOMINATED NODE   READINESS GATES
db-mysql-86f5ff66dc-sjphg   0/1     Running   0          6s    10.244.195.134   knode1   <none>           <none>
[root@kmaster linux-amd64]# 


