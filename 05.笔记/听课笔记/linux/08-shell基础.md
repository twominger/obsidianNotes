# shell基础

用户命令 -> shell解析命令并传递给内核 -> kernel执行动作

/etc/shells  提供当前系统所有可用的shell

默认/bin/bash



**[root@localhost ~]#**

[ ] : 提示符分割符号(里面是一个变量**PS1**)

root : 当前登录用户

@ : 分隔符

localhost : 主机名

~  : 家目录(当前的工作目录)

\#  : 命令提示符($ : 普通用户)



 $( ) : 引用命令执行的结果,括号里面是一条命令

 `` : 作用等同于反撇

 {1..5} : 1到5

 {1,5} : 1和5 q

### shell通配符

man 7 glob

\* :匹配**0到任意个**字符串(a\*对a1,a2,a3,a全部匹配)

? :匹配**有且只有一个**字符串(a?对a1,a2,a3,a匹配a1,a2,a3)

\[ ]: 匹配括号中列出的**有且仅有一个**字符

例如:

a[123]: 匹配a1.txt,a2.txt,a3.txt

a[1-9].txt: 匹配a1.txt……a9.txt

a[1-9]\[1-9].txt: 匹配a11.txt,a12.txt,,,,,,,a99.txt

[^m]\* : 匹配所有不是m开头的文件

?\[^e]\* : 匹配所有第二个字母不是e的文件

[^abc]\*: 匹配所有不以a或b或c开头的文件(仅)

rm -rf /temp/\* : 删除文件夹下内容

rm -rf /temp/:删除文件夹

![{91FA8696-D668-4B51-BAEB-DE3568F34DAA}](https://notes-ming.oss-cn-beijing.aliyuncs.com/images/20241221143230810.png)

### 变量

由数字,字母,下划线组成, 以字母或下划线开头, 不能使用特殊符号和空格

定义变量: 变量名=值(前后无空格,可重复赋值)

引用变量: \$(变量名)或$变量名

查看变量: echo &变量名; set查看所有的变量(本地和环境变量)

取消变量: unset变量名

例子:

a1=\$[100+1],(数字101,**[ ]里面是运算,( )里面是命令,{ }里面是变量**)

a1=100,b1=200,c1=\$[a1+b1],\(c1=300)

**本地变量:**

类似局部变量仅在当前shell中存在



**环境变量: **

在父进程中创建的环境变量在所有的子进程中都生效,反之不成立

将本地变量转换为环境变量

export 变量名(已经存在的变量)

export 变量名=值(声明变量并赋值)



**查环境变量:**

set(所有变量)

env(仅当前用户下的所有环境变量)

set |grep 变量名 (查询某变量)

env |grep 变量名

**取消变量**

unset 变量名



本地变量的应用场景: 脚本、当前shell

环境变量的应用场景: 系统使用

​	**全局环境变量: /etc/profile**(定义在该文件中的变量所有用户都可以获取到),

​	配置完之后需要执行或者重新登录之后才能获取

​	source /etc/profile

​	. /etc/profile(注意点和斜杠之间有空格)

​	./first.sh(当前目录下执行脚本,没有空格)

​	**用户环境变量: /home/.bash_profile**(定义在该文件中的变量仅当前登录的用户可以获取到)

​	  

系统中常用的变量:

PS1:命令提示符

USER:当前用户名

UID:

PATH: 

HOME:  /root

PWD: 当前工作目录的路径

[root@web01 ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

 执行命令时在PATH路径的当前层中找,不会在子目录中找,从前往后找

添加路径:

PATH=\$PATH:/root    (冒号加绝对路径)添加后可执行root目录下的脚本

PATH=\$PATH:.   (添加了一个点)添加后可执行当前目录下的脚本

应用场景:

1,当前用户下的特殊偏好,比如为了方便执行一些脚本而增加路径

2,软件有多个版本,希望执行指定版本,则把希望执行的版本的路径放到前面(最好在用户目录下)    /opt/java



登录的目的是加载用户配置,服务在操作系统启动时已经打开



**单引号和双引号的区别**

单引号: ‘  ’遇到任何特殊符号时不会转义,直接原样输出所有字符

双引号: “  ”遇到任何特殊符号时不会转义(理解为一条命令),除了以下四种情况:

\$ : 

\` ` :引用命令执行的结果,相当于\$( ); 

\  :

!  : 引用历史记录里面的指定命令,如!100(第100条),!w(以w开头的命令)

查历史命令:hystory |grep 100;

man echo: 查\作用



\ : 反斜杆转义字符,在双引号中去除特殊字符的意义,在一行的末尾表示换行

在终端定义的变量重启后都不生效,脚本中的变量仅在脚本运行过程中在当前进程中有效,并在脚本运行结束后释放



**别名alias**

定义在/etc/bashrc和~/.bashrc中，非登录shell可以调用，脚本中需要用到的环境变量可以定义在这里

alias  rm=‘rm -i’

取消别名 unalias rm





本地变量：仅在当前shell中生效

环境变量：

​	全局环境变量：

​	用户环境变量：  



IncloudOptional conf.d/\*.conf     读取目录下的所有配置文件

![{0A805108-1BAA-4A2B-A2D7-C1DDBB5FC348}](https://notes-ming.oss-cn-beijing.aliyuncs.com/images/20241221143230811.png)

字面意思，没有登录，所以也不会重新加载全局配置文件和用户配置文件

登录shell可以调用所有环境变量，非登录



**/etc/profile：**全局环境变量，非登录shell无法调用

**~/.bash_profile：**用户环境变量，非登录shell无法调用

**/etc/bashrc:**全局环境变量，

**~/.bashrc：**用户环境变量，定义了很多别名alias 别名=‘全名’，例如alias rm=‘rm -i’;

**.bash_logout：**注销的时候执行的脚本，可以保存文件等等

**.bash_history：**历史命令



**shell **  python   go   

脚本语言



first.sh  在PATH变量中寻找

./first.sh  在第一行声明的指定的目录中寻找



openssl rand -base64 5



